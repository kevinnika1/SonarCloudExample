name: Python container CI

# Controls when the workflow will run
on:
  # Triggers the workflow on push or pull request events but only for the main branch
  push:
    branches: [ master ]
  pull_request:
    branches: [ master ]

  # Allows you to run this workflow manually from the Actions tab
  workflow_dispatch:

# A workflow run is made up of one or more jobs that can run sequentially or in parallel
jobs:

   SCA:
    runs-on: ubuntu-latest
    steps: 
      - name: Checkout repo
        uses: actions/checkout@master

      - name: Run Checkov action
        id: checkov
        uses: bridgecrewio/checkov-action@master
        with:
          soft_fail: true
          output_format: cli

   SAST:
    runs-on: ubuntu-latest
    steps:
    - uses: actions/checkout@v2
    
    - name: SonarCloud Scan
      uses: sonarsource/sonarcloud-github-action@master
      env:
        GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        SONAR_TOKEN: ${{ secrets.SONAR_TOKEN }}
      with:
        args: >
          -Dsonar.organization=kevinnika1
          -Dsonar.projectKey=kevinnika1_SonarCloudExample
          -Dsonar.verbose=true

    - name: link to the project in sonar
      run: echo  "visit this link to see results of scan https://sonarcloud.io/dashboard?id=kevinnika1_SonarCloudExample"
      
   # - name: SonarQube Quality Gate check
   #   uses: sonarsource/sonarqube-quality-gate-action@master
   #   # Force to fail step after specific time
   #   timeout-minutes: 5
   #   env:
   #    SONAR_TOKEN: ${{ secrets.SONAR_TOKEN }}
       
    - name: Get Sonar Issues
      run: |
        python sonar-apis.py
        ls
        
    - name: upload sonar results to annotaions
      uses: Attest/annotations-action@v1.0.0
      with:
          token: ${{ secrets.GITHUB_TOKEN }}
          input: './sonarresults.json'
          title: 'Sonar Issues'
          
          
  
   ContainerVM:
    runs-on: ubuntu-latest
    needs: [SCA,SAST]
    steps: 
      - name:  Checkout repo
        uses: actions/checkout@master

      - name: Build an image from Dockerfile
        run: |
          docker build . --tag flask-demo-container:${{ github.sha }}
        
      - name: Run Trivy vulnerability scanner
        uses: aquasecurity/trivy-action@master
        with:
          image-ref: 'flask-demo-container:${{ github.sha }}'
          format: 'table'
          exit-code: '0'
          ignore-unfixed: true
          vuln-type: 'os,library'
          severity: 'CRITICAL,HIGH'
          output: trivy-results.txt

      - name: check trivy results file
        run: |
          cat trivy-results.txt

      - name: Upload trviy results
        uses: actions/upload-artifact@v2
        with:
          name: Conatiner VM results
          path: trivy-results.txt

   PushtoECR:
      runs-on: ubuntu-latest
      needs: [ContainerVM]
      steps:
        - name: push to ecr
          run: echo "pushing to ecr"

   CheckECR:
      runs-on: ubuntu-18.04
      needs: [PushtoECR]
      steps:
        - name: Checkout code
          uses: actions/checkout@v2
          
        - name: Run Trivy vulnerability scanner
          uses: aquasecurity/trivy-action@master
          with:
            image-ref: 'aws_account_id.dkr.ecr.region.amazonaws.com/imageName:${{ github.sha }}'
            format: 'table'
            output: 'trivyecr-results.txt'
          env:
            AWS_ACCESS_KEY_ID: key_id
            AWS_SECRET_ACCESS_KEY: access_key
            AWS_DEFAULT_REGION: us-west-2

        - name: Check exr result file
          run: cat trivyecr-results.txt

   DeployToEKS:
      runs-on: ubuntu-latest
      needs: [CheckECR]
      steps:
        - name: push to ecr
          run: echo "pushing to eks"

   # this part need to pass it website link whether that is static or not depends on application but in this case will test a random app. 
   # DAST: 
    # run-on: ubutu-latest
      
          

